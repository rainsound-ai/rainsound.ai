<!doctypehtml><html lang=en><meta charset=UTF-8><meta content=width=device-width,initial-scale=1.0 name=viewport><meta content=ie=edge http_equiv=X-UA-Compatible><link href=main.css rel=stylesheet><body class="bg-neutral-50 dark:bg-neutral-900 dark:text-white flex flex-col items-center selection:bg-neutral-200/75 dark:selection:bg-neutral-700/75"><nav class="flex gap-2 p-2 items-center justify-start w-full font-semibold text-lg"><a class="flex gap-2 items-center"dioxus-prevent-default=onclick href=/ target><span class="text-4xl font-bold">ðŸŒ¸</span><span>Hyperbloom.studio</span></a><a dioxus-prevent-default=onclick href=/ target>Home</a><a dioxus-prevent-default=onclick href=/contact target>Contact</a></nav><main><h1>Contact</h1><p>O hai mark<form class="flex flex-col gap-2 w-full max-w-2xl py-4"action=http://localhost:8787/contact method=POST><label><p>Name</p><input name=name required></label><label><p>Email</p><input name=email required></label><label><p>Message</p><textarea name=message required></textarea></label><button>Send</button></form></main><script type=module>// Use ES module import syntax to import functionality from the module
// that we have compiled.
//
// Note that the `default` import is an initialization function which
// will "boot" the module and make it ready to use. Currently browsers
// don't support natively imported WebAssembly as an ES module, but
// eventually the manual initialization won't be required!
// import init, { greet } from './browser.js'
import init from './browser.js'

async function main () {
  // First up we need to actually load the wasm file, so we use the
  // default export to inform it where the wasm file is located on the
  // server, and then we wait on the returned promise to wait for the
  // wasm to be loaded.
  //
  // It may look like this: `await init('./pkg/without_a_bundler_bg.wasm');`,
  // but there is also a handy default inside `init` function, which uses
  // `import.meta` to locate the wasm file relatively to js file.
  //
  // Note that instead of a string you can also pass in any of the
  // following things:
  //
  // * `WebAssembly.Module`
  //
  // * `ArrayBuffer`
  //
  // * `Response`
  //
  // * `Promise` which returns any of the above, e.g. `fetch("./path/to/wasm")`
  //
  // This gives you complete control over how the module is loaded
  // and compiled.
  //
  // Also note that the promise, when resolved, yields the wasm module's
  // exports which is the same as importing the `*_bg` module in other
  // modes
  await init()

  // And afterwards we can use all the functionality defined in wasm.
  // greet()
}

main()
</script>